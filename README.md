# A Class' SSH Server in Kubernetes 

Since the dawn of the modern operating system, computer classes have used a shared login server to create a work environment for students. In the cloud era we've used virtual machines in place of physical servers (IaaS) to make our workloads more convenient to manage. But, our severs are still *pets*, they are precious to us, because they are stateful appliances running bespoke applications with some real problems: 

1. They are a single point of failure that impacts our ability to teach. 
1. Students are a security risk. I once caught a student who was able to maintain access after the end of a term. 
1. Management tools like VMware are clunky compared to cloud vendors. 
1. Cloud vendors are expensive for this kind of workload. 

This project is a way to deploy a traditional login server into a Kubernetes cluster. I started working on it as a way to get a deeper understanding of cloud-native computing.
 
## Quickstart 

You should have a Kubernetes cluster already built and `kubectl` and `helm` installed and configured. 

1. Check out this repo: 

    ```console
    $ git clone https://github.com/mike-matera/cloud-native-server.git
    $ cd cloud-native-server
    ```

2. Generate the SSH CA key: 

    ```console
    $ make
    ```

3. Create a file called `custom.yaml` with the following contents: 

    ```yaml
    rcEnv: |
        DEFAULT_USER="admin" 
        DEFAULT_KEY=""
        DEFAULT_KEY_IMPORT=""
        SET_HOSTNAME="myserver"
        CUSTOMIZE_REPO="https://github.com/mike-matera/cloud-native-server.git"
        CUSTOMIZE_CMD="ansible-playbook --connection=local --inventory 127.0.0.1, --limit 127.0.0.1 init/playbook.yaml"
    ```

    Update the `DEFAULT_KEY` variable to hold your SSH public key or the `DEFAULT_KEY_IMPORT` to a string suitable for [ssh-import-id](https://manpages.ubuntu.com/manpages/jammy/man1/ssh-import-id.1.html) to load public keys from your GitHub or Launchpad accounts. Update the `DEFAULT_USER` and `HOSTNAME` if you like. 

4. Use `helm` to deploy your server: 

    ```console 
    $ helm install test-ssh chart --values custom.yaml --values secrets/ssh-keys.yaml
    ```

5. Wait for the application to deploy and check the service IP:

    ```console
    $ kubectl get service
    NAME                    TYPE           CLUSTER-IP       EXTERNAL-IP    PORT(S)        AGE
    test-ssh-cloud-server   LoadBalancer   10.152.183.173   172.20.2.100   22:31456/TCP   5s
    ```

    Login using the IP address:

    ```console
    $ ssh admin@172.20.2.100
    ```

## Configuration 

There are three configuration stages:

1. The `Dockerfile` build. The purpose of this stage is have a functional base container with most of good stuff installed. This is the least flexible stage. 
1. The execution of `rc.local` on boot. This stage customizes the image with SSH keys and creates the admin user. 
1. Executing an arbitrary command in an arbitrary GIT repository. This is the most flexible stage. 

The next sections describe how to customize each stage. 

### Custom Docker Images 

You can find the `Dockerfile` for the supported distros in the `containers` directory. If you clone this repository on GitHub you can reuse the `.github/workflows/*` files to build your own packages. Container builds are triggered by certain tags. For example, the Ubuntu container is build on a `jammy-*` tag. 

If you use a custom image add the following lines to your `custom.yaml` from the quickstart:

```yaml
image:
  repository: ghcr.io/your-github-name-here/cloud-native-server
  tag: "your-tag-here"
```

Helm will then deploy your custom image. 

#### Why customize the image? 

1. If you want **a lot** of new or different packages installed. You can install packages during the user customization stage. 
1. If you want to use Puppet or Chef instead of Ansible.
1. If you want to use a non-supplied distro. 
 
### Customizing Boot 

The images use `systemd` to run the classic `rc.local` script. This works well because there's existing infrastructure so not much image customization has to be done. The `sshd` service has been updated to wait for the `rc-local` service to finish, because SSH keys are generated by `/etc/rc.local`. The contents of `/etc/rc.local` are in the Helm chart. You can update the script by adding the following key to `custom.yaml`:

```yaml
rcLocal: |
  #! /usr/bin/bash
  set -e 

  . /etc/rc.env 
  
  [...your code here...]
```

You should look at the existing code in `chart/values.yaml`. There are a few important things that the `rc.local` script must do: 

1. Set the hostname 
1. Create SSH host keys and sign them with the SSH CA key 
1. Create the admin user, make sure they have `sudo` access and install their SSH public keys 
1. Any personal customization 
1. Touch the `/ready` file to tell kubernetes that the container is ready. 

#### Why customize boot? 

1. If you have another way to deliver customization, i.e. Puppet or Chef networks.

### User Customization 

The default `rc.local` script looks for the existence of two variables that can be overridden using the `rcEnv` key in your `custom.yaml` file: 

```
rcEnv: |
    DEFAULT_USER="admin" 
    DEFAULT_KEY=""
    DEFAULT_KEY_IMPORT=""
    SET_HOSTNAME="myserver"
    CUSTOMIZE_REPO="https://github.com/mike-matera/cloud-native-server.git"
    CUSTOMIZE_CMD="ansible-playbook --connection=local --inventory 127.0.0.1, --limit 127.0.0.1 init/playbook.yaml"
```

The `rc.local` script does the equivalent of: 

```bash 
git clone --recurse-submodules $CUSTOMIZE_REPO /tmp/repo-root
cd /tmp/repo-root 
$CUSTOMIZE_CMD
```

The commands are run as the user `$DEFAULT_USER`, not `root`. The variables from `rcEnv` are defined so you can add variables to `rcEnv` that are used by your custom repository command. The Ansible playbooks in `/init` are an example of how you can customize your systems.  

#### Why do user customization? 

1. This is the easiest way to customize your server. Try this first. 


